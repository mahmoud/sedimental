# TODO

* Purpose behind source: If you find a typo or error, send me an
  email. Or even better, right-click/save-as the "View Source" link,
  send me a diff!

## Lists

* Coverage for Hatnote projects
* Bugs I've filed against CPython
* People I've worked closely with
* Phone apps that I use
* Favorite stories (md)
* Respectable Programmers (links to blogs, github, twitter of djb/phk/gvr)

## Ancillary Words

* Extended AKA Subtitle: "How I Learned to Love Chert"
* Timed summary: "Your 5-minute guide to building great projects."
* Publication note: "This was initially published elsewhere" or "This is part of a series of helpful posts."
* Edits/updates: "EDIT 9/5/2016: Refreshed some links, added note about the Internet."

## Entry Ideas

### Avoiding Import Nightmares

Even though it's safe to assume any given Python project will include
many, many files, how you take that first step from one file to
multiple is a critical. Python's reputation for "one obvious way" to
do things starts to break down with imports and by the time we reach
packaging, not even the number of ways is obvious.

This isn't all Python's fault. Python's adaptability is to credit for
its longevity. The packaging is improving, with the fast rise of
wheels as the best and brightest way to package libraries. Python is a
general-purpose language with a specific-purpose packaging system. wheels, setuptools, pip and

* Flask as an example of an architecture that invites/encourages circular imports
* Use absolute imports
    * setup.py develop
* Python is a powerful language. The basic in-built language
  constructs are all it takes for composing large applications.

### Places I Would Work


### The grease we need

Agile and DevOps tries to move the creative work of development
further from the areas that need it, recreating the cardinal error of
waterfall.
